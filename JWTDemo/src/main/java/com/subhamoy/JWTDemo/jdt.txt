1ï¸âƒ£ Normal Spring Security (Session-Based)

Flow:

User â†’ Login (username + password)
        â†“
Authentication â†’ Session created on server
        â†“
Server stores session ID
        â†“
Client gets session ID (cookie)
        â†“
Client sends cookie with every API call
        â†“
Server checks session â†’ allows access


Key Points:

Server stores session for each user
Stateful â†’ server memory used
Cookie is auto sent by browser
Works well for server-rendered apps (JSP, Thymeleaf)
Scaling is harder â†’ need session replication for multiple servers

2ï¸âƒ£ JWT-Based Security (Token-Based)

Flow:

User â†’ Login (username + password)
        â†“
Authentication â†’ JWT generated
        â†“
Server sends JWT to client
        â†“
Client stores JWT (localStorage / header)
        â†“
Client sends JWT with every API request
        â†“
Server validates JWT â†’ allows access


Key Points:

Server does NOT store session
Stateless â†’ highly scalable
JWT contains user info + expiry + signature
Works well for REST APIs, React, Mobile apps
Token must be sent manually in Authorization header

4ï¸âƒ£ Simple Analogy

Normal Security â†’ Hotel key card issued at front desk, hotel keeps record
JWT â†’ Prepaid pass with your info embedded, hotel doesnâ€™t need to keep record, just verify pass

5ï¸âƒ£ One-line Interview Answer

Normal security is stateful with server sessions; JWT is stateless, scalable,
and the token itself proves authentication and authorization.




ğŸ” JWT Structure (Very Short)

JWT = 3 parts separated by dots (.)
HEADER . PAYLOAD . SIGNATURE

1ï¸âƒ£ Header â€“ algorithm + token type
{ "alg": "HS256", "typ": "JWT" }

2ï¸âƒ£ Payload â€“ user data + expiry
{ "username": "user", "role": "USER", "exp": 1700000000 }

3ï¸âƒ£ Signature â€“ verifies token is not tampered
HMAC(header + payload, secret key)










